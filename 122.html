<!DOCTYPE html>
<html>
<head>
    <title>برف سه‌بعدی فوق واقعی</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0a0a1a;
        }
        canvas { 
            display: block; 
            position: fixed;
            z-index: -1;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // 1. تنظیمات پایه
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. نورپردازی طبیعی
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 3. سیستم ذرات پیشرفته
        const particleCount = 5000;
        const particles = new THREE.BufferGeometry();
        
        // موقعیت‌ها و ویژگی‌های تصادفی
        const posArray = new Float32Array(particleCount * 3);
        const sizeArray = new Float32Array(particleCount);
        const velArray = new Float32Array(particleCount);
        const rotArray = new Float32Array(particleCount);
        
        for(let i = 0; i < particleCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 200;
            sizeArray[i/3] = Math.random() * 0.5 + 0.1;
            velArray[i/3] = Math.random() * 0.1 + 0.05;
            rotArray[i/3] = Math.random() * Math.PI * 2;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
        particles.setAttribute('velocity', new THREE.BufferAttribute(velArray, 1));
        particles.setAttribute('rotation', new THREE.BufferAttribute(rotArray, 1));

        // 4. متریال سفارشی با Shader
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.2,
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        // 5. ایجاد سیستم ذرات
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // 6. افکت Bloom برای درخشش
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(bloomPass);

        // 7. انیمیشن پیشرفته
        camera.position.z = 50;
        let windDirection = 0;
        let windSpeed = 0.01;

        function animate() {
            requestAnimationFrame(animate);
            
            // تغییر جهت باد به صورت طبیعی
            windDirection += (Math.random() - 0.5) * 0.02;
            windSpeed = 0.01 + Math.sin(Date.now() * 0.001) * 0.005;
            
            // به‌روزرسانی موقعیت ذرات
            const positions = particles.attributes.position.array;
            const rotations = particles.attributes.rotation.array;
            
            for(let i = 0; i < particleCount; i++) {
                // حرکت عمودی با سرعت‌های مختلف
                positions[i * 3 + 1] -= velArray[i];
                
                // حرکت افقی با اثر باد
                positions[i * 3] += Math.sin(windDirection) * windSpeed;
                positions[i * 3 + 2] += Math.cos(windDirection) * windSpeed;
                
                // چرخش ذرات
                rotations[i] += 0.01;
                
                // بازگرداندن ذرات به بالا وقتی به پایین رسیدند
                if(positions[i * 3 + 1] < -100) {
                    positions[i * 3 + 1] = 100;
                    positions[i * 3] = (Math.random() - 0.5) * 200;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                }
            }
            
            particles.attributes.position.needsUpdate = true;
            particles.attributes.rotation.needsUpdate = true;
            
            // چرخش ملایم سیستم برای حس عمق
            particleSystem.rotation.y += 0.0005;
            
            // رندر با افکت‌های پس‌پردازش
            composer.render();
        }

        // 8. واکنش به حرکت موس
        document.addEventListener('mousemove', (e) => {
            camera.position.x = (e.clientX / window.innerWidth - 0.5) * 30;
            camera.position.y = -(e.clientY / window.innerHeight - 0.5) * 30;
        });

        // 9. تنظیم مجدد هنگام تغییر سایز پنجره
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
